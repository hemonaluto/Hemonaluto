<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>game.controller.dungeon_controller API documentation</title>
<meta name="description" content="kind of like a dungeon master that controls everything that&#39;s happening in the in-game world" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>game.controller.dungeon_controller</code></h1>
</header>
<section id="section-intro">
<p>kind of like a dungeon master that controls everything that's happening in the in-game world</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;kind of like a dungeon master that controls everything that&#39;s happening in the in-game world&#34;&#34;&#34;
import re
import pkg_resources
from typing import Tuple
from game.model.element import Element
from game.model.location import Location
from game.model.activator import Activator
from game.model.animate import Animate
from game.model.chest import Chest
from game.model.door import Door
from game.model.player import Player
from game.model.rope import Rope
from game.model.thing import Thing
from game.model.tool import Tool
from game.model.enums.activator_type import ActivatorType
from game.helper_methods import isinstanceorsubclass
from game.controller.activator_controller import ActivatorController
from game.controller.save_controller import SaveController
from game.data.texts import ACTION_FAILED, ACTION_NOT_POSSIBLE, ALREADY_OFF, ALREADY_ON,\
    ALREADY_UNTIED, APPEARING, CANT_BREAK, CANT_SEE_LOCATION_FROM_HIDING,\
    CANT_TIE_TO_ELEMENT, CLIMBING_DOWN, CLOSED, DONE, DOWN,\
    FAILED_SAVE_MESSAGE, KEY_MISSING, LOADED_SAVE_MESSAGE, LOCATION_PREFIX,\
    LOCATION_SUFFIX, NEEDS_TO_BE_TOOL, NO_SMELLS, NO_TIED_ROPE, NOT_ENTERABLE,\
    NOT_HIDING, NOT_OPENABLE, NOT_READABLE, NOTHING_HAPPENS, SAVED_GAME_MESSAGE,\
    SILENCE, SPECIFIY_HIDING_PLACE, TARGET_NOT_SPECIFIED, THAT_WONT_HOLD,\
    THREW_AT_NOTHING, TURNED_OFF, TURNED_ON, UNTIE, WEAPON_NOT_SPECIFIED,\
    door_leads_to, door_not_locked, door_unlocked, GENERIC_LOCATAION_NAME,\
    INVALID_DIRECTION, LOCKED_DOOR, eat_food, element_not_found, element_not_in_inventory,\
    entering_thing, hit_target, noises_description, picked_up_element,\
    element_in_container, reveal_element, smell_description, tie_rope_to_target


class DungeonController:
    &#34;&#34;&#34;dungeon controller (dungeon master) class&#34;&#34;&#34;
    def __init__(self):
        self.player_location = None
        self.all_name_locations = []
        self.save_handler = SaveController()
        self.player_score = 0
        self.activator_handler = ActivatorController()
    
    def brief(self, room_name: str):
        &#34;&#34;&#34;Debrief the player if they arrive at a location they&#39;ve never been&#34;&#34;&#34;
        for name_location in self.all_name_locations:
            if name_location[0] == room_name and not name_location[1].visited and name_location[1].brief:
                name_location[1].visited = True
                return name_location[1].brief + &#34;\n\n&#34;
        return &#34;&#34;

    def get_player(self):
        &#34;&#34;&#34;Get the player object from the current location&#34;&#34;&#34;
        return self.get_element_container(&#34;Player&#34;, self.player_location)[0]

    def get_score(self):
        &#34;&#34;&#34;Get the current score&#34;&#34;&#34;
        return self.player_score

    def get_health(self):
        &#34;&#34;&#34;Get the current health&#34;&#34;&#34;
        return self.get_player().health

    def move_player(self, direction: str):
        &#34;&#34;&#34;Move the player from one location to the next, which lies in the given direction&#34;&#34;&#34;
        if direction in self.player_location.exits:
            travel_text = &#34;&#34;
            all_name_rooms_dict =  dict(self.all_name_locations)
            next_room = all_name_rooms_dict[self.player_location.exits[direction]]
            room_has_attached_rope = False
            for element in self.player_location.contents:
                if isinstanceorsubclass(element, Door):
                    if next_room.name in element.connects and element.locked:
                        return LOCKED_DOOR
                    element.open = True
                if isinstanceorsubclass(element, Rope) and direction == DOWN and next_room.needs_rope:
                    if not element.tied_to:
                        return NO_TIED_ROPE
                    room_has_attached_rope = True
                    travel_text = CLIMBING_DOWN + &#34;\n&#34;
            if next_room.needs_rope and room_has_attached_rope is False:
                return NO_TIED_ROPE
            player = self.get_player()
            self.player_location.contents.remove(player)
            self.set_player_location(player, next_room)
            brief_text = &#34;&#34;
            brief_text = self.brief(next_room.name)
            return f&#34;{travel_text}{brief_text}{self.player_location.name}&#34;
        return INVALID_DIRECTION

    def unlock(self, door_name: str):
        &#34;&#34;&#34;Unlocks and opens a door&#34;&#34;&#34;
        door = self.get_element_container(door_name, self.player_location)[0]
        if not door.locked:
            return door_not_locked(door_name)
        if any(element.name == door.key for element in self.get_player().contents):
            self.player_score = self.player_score + 1
            door.locked = False
            return door_unlocked(door_name)
        return KEY_MISSING

    def set_player_location(self, player: Player, location: Location):
        &#34;&#34;&#34;Update the players location to a new one&#34;&#34;&#34;
        location.contents.append(player)
        self.player_location = location

    def describe(self, element_name: str):
        &#34;&#34;&#34;Returns a desription of any kind of in-game element at the location of the player&#34;&#34;&#34;
        element_name = element_name.lower()
        if element_name in (self.player_location.name, GENERIC_LOCATAION_NAME, &#39;&#39;):
            return self.describe_location()
        return self.describe_element(element_name)

    def describe_location(self):
        &#34;&#34;&#34;Describes the location where the player is&#34;&#34;&#34;
        if not self.get_player().hiding:
            return self.describe_container(self.player_location, (LOCATION_PREFIX, LOCATION_SUFFIX))
        return CANT_SEE_LOCATION_FROM_HIDING

    def describe_element(self, element_name: str):
        &#34;&#34;&#34;Get description of a single element&#34;&#34;&#34;
        element_container = self.get_element_container(element_name, self.player_location)
        if element_container:
            return self.describe_container(element_container[0])
        else:
            return element_not_found(element_name)

    def describe_container(self, top_container: Element, prefix_suffix=None):
        &#34;&#34;&#34;Descsribe any container and its contents and all the contents contents etc.&#34;&#34;&#34;
        if prefix_suffix:
            description = top_container.name + &#34;\n&#34; + prefix_suffix[0] +\
                top_container.description.lower() + prefix_suffix[1]
        else:
            description = top_container.description
        visible_elements = self.get_all_elements_container(top_container, only_visible=True)
        for element_container in visible_elements:
            if element_container[1] is not self.get_player():
                if element_container[1] is not self.player_location:
                    description = description + &#34;\n&#34; +\
                        element_in_container(element_container[0].name,\
                        element_container[1].preposition,\
                        element_container[1].name)
                else:
                    if not isinstanceorsubclass(element_container[0], Player):
                        description = description + &#34;\n&#34; + element_container[0].description
                    if isinstanceorsubclass(element_container[0], Door):
                        description = description + &#34; &#34; + door_leads_to(self.get_door_directions(element_container))
        return description

    def get_door_directions(self, door_container: Tuple[Door, Element]):
        &#34;&#34;&#34;Get the directions a door leads to&#34;&#34;&#34;
        directions = [] 
        for direction_location in door_container[1].exits.items():
            if direction_location[1] in door_container[0].connects:
                directions.append(direction_location[0])
        return directions

    def get_element_container(self, compare_element_name: str, container: Element, only_visible: bool = True):
        &#34;&#34;&#34;Get an element in the container
        by its name and the corresponding container.
        If it&#39;s not found it returns None&#34;&#34;&#34;
        vague_matches = []
        for element_container in self.get_all_elements_container(container, only_visible):
            element = element_container[0]
            if bool(set(compare_element_name.lower().split()) &amp; set(element.name.lower().split())):
                vague_matches.append((element, element_container[1]))
        if len(vague_matches) &gt; 1:
            for vague_match in vague_matches:
                if vague_match[0].name.lower() == compare_element_name.lower():
                    return vague_match
        if len(vague_matches) == 1:
            return vague_matches[0]
        return None

    def get_all_elements_container(self, container: Element, only_visible: bool = False, only_takeable: bool = False):
        &#34;&#34;&#34;Recursive method to get all elements in the container
        and their corresponding container. If there is nothing it returns None&#34;&#34;&#34;
        elements_container = []
        if only_takeable:
            for element in container.contents:
                if isinstanceorsubclass(element, Thing) and element.visible and not element.fixed:
                    elements_container.append((element, container))
                elements_container = elements_container +\
                    self.get_all_elements_container(element, only_visible, only_takeable)
            return elements_container
        if only_visible:
            for element in container.contents:
                if element.visible:
                    elements_container.append((element, container))
                if isinstanceorsubclass(element, Chest) and not element.peekable or\
                isinstanceorsubclass(element, Chest) and not element.open:
                    pass
                else:
                    elements_container = elements_container +\
                        self.get_all_elements_container(element, only_visible)
            return elements_container
        if not only_visible:
            for element in container.contents:
                elements_container.append((element, container))
                elements_container = elements_container +\
                    self.get_all_elements_container(element, only_visible)
            return elements_container
        return None

    def take(self, element_name: str):
        &#34;&#34;&#34;Take all elements or a single element and put it into the players inventory&#34;&#34;&#34;
        if element_name == &#34;all&#34;:
            all_takeable = self.get_all_elements_container(self.player_location, only_takeable=True)
            response = &#34;&#34;
            for element_container in all_takeable:
                if not isinstanceorsubclass(element_container[0], Player) and not element_container[0].fixed:
                    element_container[1].contents.remove(element_container[0])
                    self.get_player().contents.append(element_container[0])
                    response = response + picked_up_element(element_container[0].name) + &#34;\n&#34;
            return response
        element_container = self.get_element_container(element_name, self.player_location)
        if not element_container:
            return element_not_found(element_name)
        element_container[1].contents.remove(element_container[0])
        self.get_player().contents.append(element_container[0])
        return picked_up_element(element_container[0].name)

    def get_player_inventory(self):
        &#34;&#34;&#34;Returns the invenotry of the player as a string listing all things&#34;&#34;&#34;
        description = &#34;&#34;
        for element in self.get_player().contents:
            description = description + element.name + &#34;\n&#34;
        return description

    def save(self):
        &#34;&#34;&#34;Saves the game state to file&#34;&#34;&#34;
        if self.save_handler.save(self.all_name_locations, pkg_resources.resource_filename(&#34;game.data&#34;, &#34;save.json&#34;)):
            return SAVED_GAME_MESSAGE
        return FAILED_SAVE_MESSAGE

    def load(self, filename: str):
        &#34;&#34;&#34;Loads the game state from file&#34;&#34;&#34;
        load_data = self.save_handler.load(filename)
        self.all_name_locations = load_data[0]
        self.player_location = load_data[1]
        return LOADED_SAVE_MESSAGE

    def throw(self, instructions: str):
        &#34;&#34;&#34;Throws an item&#34;&#34;&#34;
        if &#34;at&#34; in instructions:
            thing_target = instructions.split(&#34; at &#34;)
            thing_container = self.get_element_container(thing_target[0], self.get_player())[0]
            if thing_container is None:
                return element_not_found(thing_container.name)
            target_container = self.get_element_container(thing_target[1], self.player_location)[0]
            if target_container is None:
                return element_not_found(target_container.name)
            if isinstanceorsubclass(target_container, Animate):
                self.get_player().contents.remove(thing_container)
                target_container.health = target_container.health - thing_container.damage * 1.5
                self.player_location.contents.append(thing_container)
                return hit_target(target_container.name)
        thing_container = self.get_element_container(instructions, self.player_location)
        self.get_player().contents.remove(thing_container[0])
        self.player_location.contents.append(thing_container[0])
        return THREW_AT_NOTHING

    def close(self, element_name: str):
        &#34;&#34;&#34;Closes a door or chest element&#34;&#34;&#34;
        element_container = self.get_element_container(element_name, self.player_location)
        if isinstanceorsubclass(element_container[0], (Chest, Door)):
            element_container[0].open = False
            return CLOSED
        return NOT_OPENABLE

    def read(self, element_name: str):
        &#34;&#34;&#34;Read an elements text&#34;&#34;&#34;
        element_container = self.get_element_container(element_name, self.player_location)
        if isinstanceorsubclass(element_container[0], Thing) and element_container[0].text:
            return element_container[0].text
        return NOT_READABLE

    def put(self, instructions: str):
        &#34;&#34;&#34;Put element into the contents of another element&#34;&#34;&#34;
        if &#34; in &#34; in instructions or &#34; on &#34; in instructions:
            thing_target = re.split(&#34; in | on &#34;, instructions)
            thing_container = self.get_element_container(thing_target[0], self.get_player())
            if thing_container is None:
                return element_not_found(thing_target[0])
            target_container = self.get_element_container(thing_target[1], self.player_location)
            if target_container is None:
                return element_not_found(thing_target[1])
            thing_container[1].contents.remove(thing_container[0])
            target_container[0].contents.append(thing_container[0])
            return DONE
        return TARGET_NOT_SPECIFIED

    def activate(self, instructions: str, expected_activator_type: ActivatorType):
        &#34;&#34;&#34;Activate an activator&#34;&#34;&#34;
        split_input = instructions.split()
        if &#34;on&#34; in instructions.split():
            split_input.remove(&#34;on&#34;)
            activator = self.get_element_container(split_input[0], self.player_location)[0]
            if not self.turn_on(activator, self.activator_handler):
                return ALREADY_ON
            return TURNED_ON
        if &#34;off&#34; in instructions.split():
            split_input.remove(&#34;off&#34;)
            activator = self.get_element_container(split_input[0], self.player_location)[0]
            if not self.turn_off(activator, self.activator_handler):
                return ALREADY_OFF
            return TURNED_OFF
        activator = self.get_element_container(instructions, self.player_location)[0]
        if not activator:
            return element_not_found(instructions)
        if not expected_activator_type is activator.type:
            return ACTION_NOT_POSSIBLE
        if activator.is_on is True:
            return self.turn_off(activator, self.activator_handler)
        if activator.is_on is False:
            return self.turn_on(activator, self.activator_handler)
        return ACTION_FAILED

    def turn_on(self, activator: Activator, activator_handler: ActivatorController):
        &#34;&#34;&#34;Turns an activator on&#34;&#34;&#34;
        if activator.is_on:
            return ALREADY_ON
        turn_on_method = getattr(activator_handler, activator.turn_on_method_name)
        activator.is_on = True
        if turn_on_method:
            return turn_on_method()
        return NOTHING_HAPPENS

    def turn_off(self, activator: Activator, activator_handler: ActivatorController):
        &#34;&#34;&#34;Turns an activator off&#34;&#34;&#34;
        if not activator.is_on:
            return ALREADY_OFF
        turn_off_method = getattr(activator_handler, activator.turn_off_method_name)
        activator.is_on = False
        if turn_off_method:
            return turn_off_method()
        return NOTHING_HAPPENS

    def move_element(self, element_name: str):
        &#34;&#34;&#34;Moves element&#34;&#34;&#34;
        element_container = self.get_element_container(element_name, self.player_location)
        if not element_container:
            return element_not_found(element_name)
        element_container[0].moved = True
        revealed_element = self.get_element_container(element_container[0].reveals,\
            self.player_location, only_visible=False)[0]
        revealed_element.visible = True
        return reveal_element(element_name, revealed_element.description.lower())

    def attack(self, instructions: str):
        &#34;&#34;&#34;Attacks a target&#34;&#34;&#34;
        if &#34;with&#34; in instructions:
            target_thing = instructions.split(&#34; with &#34;)
            tool_container = self.get_element_container(target_thing[1], self.get_player())
            if tool_container is None:
                return element_not_in_inventory(target_thing[1])
            if not isinstanceorsubclass(tool_container[0], Tool):
                return NEEDS_TO_BE_TOOL
            target_container = self.get_element_container(target_thing[0], self.player_location)
            if target_container is None:
                return element_not_found(target_thing[0])
            if isinstanceorsubclass(target_container[0], Animate):
                target_container[0].health = target_container[0].health - tool_container[0].damage
                return hit_target(target_container[0].name)
            if isinstanceorsubclass(target_container[0], Thing):
                if not target_container[0].when_broken_do:
                    return CANT_BREAK
                break_method = getattr(self.activator_handler, target_container[0].when_broken_do)
                target_container[1].contents.remove(target_container[0])
                target_container[1].contents.append(\
                    Thing(&#34;broken &#34; + target_container[0].name,\
                    target_container[0].description))
                return break_method()
        return WEAPON_NOT_SPECIFIED

    def eat(self, element_name: str):
        &#34;&#34;&#34;Feeds the player&#34;&#34;&#34;
        food = self.get_element_container(element_name, self.player_location)[0]
        if not food:
            return element_not_found(food)
        self.get_player().health += food.regen
        return eat_food(food.name, food.taste)

    def tie(self, instructions: str):
        &#34;&#34;&#34;Ties a rope to something&#34;&#34;&#34;
        if &#34;to&#34; in instructions:
            thing_target = instructions.split(&#34; to &#34;)
            thing_container = self.get_element_container(thing_target[0], self.get_player())
            if thing_container is None:
                return element_not_in_inventory(thing_target[0])
            target_container = self.get_element_container(thing_target[1], self.player_location)
            if target_container is None:
                return element_not_found(thing_target[1])
            if not isinstanceorsubclass(target_container[0], Thing):
                return CANT_TIE_TO_ELEMENT
            if not target_container[0].fixed:
                return THAT_WONT_HOLD
            if isinstanceorsubclass(thing_container[0], Rope):
                self.get_player().contents.remove(thing_container[0])
                target_container[1].contents.append(thing_container[0])
                thing_container[0].tied_to = target_container[0].name
                return tie_rope_to_target(target_container[0].name.lower())
        return TARGET_NOT_SPECIFIED

    def untie(self, rope_name: str):
        &#34;&#34;&#34;Unties a rope&#34;&#34;&#34;
        rope = self.get_element_container(rope_name, self.player_location)
        if rope is None:
            return element_not_found(rope_name)
        if self.get_element_container(rope.tied_to, self.player_location):
            rope.tied_to = None
            return UNTIE
        return ALREADY_UNTIED

    def listen(self):
        &#34;&#34;&#34;Listens to environment&#34;&#34;&#34;
        noises = []
        for element_container in self.get_all_elements_container(self.player_location):
            if element_container[0].sound:
                noises.append(element_container[0].sound)
        if len(noises) == 0:
            return SILENCE
        return noises_description(noises)

    def smell(self):
        &#34;&#34;&#34;Smells the environment&#34;&#34;&#34;
        smells = []
        for element_container in self.get_all_elements_container(self.player_location):
            if element_container[0].smell:
                smells.append(element_container[0].smell)
        if len(smells) == 0:
            return NO_SMELLS
        return smell_description(smells)

    def hide(self, instructions: str):
        &#34;&#34;&#34;Hides player in thing&#34;&#34;&#34;
        if &#34;in&#34; in instructions or &#34;under&#34; in instructions:
            target = re.split(&#34;in|under&#34;, instructions)[1]
            element_container = self.get_element_container(target, self.player_location)
            if isinstanceorsubclass(element_container[0], Thing) and element_container[0].enterable:
                self.get_player().hiding = True
                return entering_thing(element_container[0].name)
            return NOT_ENTERABLE
        return SPECIFIY_HIDING_PLACE

    def appear(self):
        &#34;&#34;&#34;Puts player out of hiding&#34;&#34;&#34;
        player = self.get_player()
        if player.hiding is True:
            player.hiding = False
            return APPEARING
        return NOT_HIDING</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="game.controller.dungeon_controller.DungeonController"><code class="flex name class">
<span>class <span class="ident">DungeonController</span></span>
</code></dt>
<dd>
<div class="desc"><p>dungeon controller (dungeon master) class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DungeonController:
    &#34;&#34;&#34;dungeon controller (dungeon master) class&#34;&#34;&#34;
    def __init__(self):
        self.player_location = None
        self.all_name_locations = []
        self.save_handler = SaveController()
        self.player_score = 0
        self.activator_handler = ActivatorController()
    
    def brief(self, room_name: str):
        &#34;&#34;&#34;Debrief the player if they arrive at a location they&#39;ve never been&#34;&#34;&#34;
        for name_location in self.all_name_locations:
            if name_location[0] == room_name and not name_location[1].visited and name_location[1].brief:
                name_location[1].visited = True
                return name_location[1].brief + &#34;\n\n&#34;
        return &#34;&#34;

    def get_player(self):
        &#34;&#34;&#34;Get the player object from the current location&#34;&#34;&#34;
        return self.get_element_container(&#34;Player&#34;, self.player_location)[0]

    def get_score(self):
        &#34;&#34;&#34;Get the current score&#34;&#34;&#34;
        return self.player_score

    def get_health(self):
        &#34;&#34;&#34;Get the current health&#34;&#34;&#34;
        return self.get_player().health

    def move_player(self, direction: str):
        &#34;&#34;&#34;Move the player from one location to the next, which lies in the given direction&#34;&#34;&#34;
        if direction in self.player_location.exits:
            travel_text = &#34;&#34;
            all_name_rooms_dict =  dict(self.all_name_locations)
            next_room = all_name_rooms_dict[self.player_location.exits[direction]]
            room_has_attached_rope = False
            for element in self.player_location.contents:
                if isinstanceorsubclass(element, Door):
                    if next_room.name in element.connects and element.locked:
                        return LOCKED_DOOR
                    element.open = True
                if isinstanceorsubclass(element, Rope) and direction == DOWN and next_room.needs_rope:
                    if not element.tied_to:
                        return NO_TIED_ROPE
                    room_has_attached_rope = True
                    travel_text = CLIMBING_DOWN + &#34;\n&#34;
            if next_room.needs_rope and room_has_attached_rope is False:
                return NO_TIED_ROPE
            player = self.get_player()
            self.player_location.contents.remove(player)
            self.set_player_location(player, next_room)
            brief_text = &#34;&#34;
            brief_text = self.brief(next_room.name)
            return f&#34;{travel_text}{brief_text}{self.player_location.name}&#34;
        return INVALID_DIRECTION

    def unlock(self, door_name: str):
        &#34;&#34;&#34;Unlocks and opens a door&#34;&#34;&#34;
        door = self.get_element_container(door_name, self.player_location)[0]
        if not door.locked:
            return door_not_locked(door_name)
        if any(element.name == door.key for element in self.get_player().contents):
            self.player_score = self.player_score + 1
            door.locked = False
            return door_unlocked(door_name)
        return KEY_MISSING

    def set_player_location(self, player: Player, location: Location):
        &#34;&#34;&#34;Update the players location to a new one&#34;&#34;&#34;
        location.contents.append(player)
        self.player_location = location

    def describe(self, element_name: str):
        &#34;&#34;&#34;Returns a desription of any kind of in-game element at the location of the player&#34;&#34;&#34;
        element_name = element_name.lower()
        if element_name in (self.player_location.name, GENERIC_LOCATAION_NAME, &#39;&#39;):
            return self.describe_location()
        return self.describe_element(element_name)

    def describe_location(self):
        &#34;&#34;&#34;Describes the location where the player is&#34;&#34;&#34;
        if not self.get_player().hiding:
            return self.describe_container(self.player_location, (LOCATION_PREFIX, LOCATION_SUFFIX))
        return CANT_SEE_LOCATION_FROM_HIDING

    def describe_element(self, element_name: str):
        &#34;&#34;&#34;Get description of a single element&#34;&#34;&#34;
        element_container = self.get_element_container(element_name, self.player_location)
        if element_container:
            return self.describe_container(element_container[0])
        else:
            return element_not_found(element_name)

    def describe_container(self, top_container: Element, prefix_suffix=None):
        &#34;&#34;&#34;Descsribe any container and its contents and all the contents contents etc.&#34;&#34;&#34;
        if prefix_suffix:
            description = top_container.name + &#34;\n&#34; + prefix_suffix[0] +\
                top_container.description.lower() + prefix_suffix[1]
        else:
            description = top_container.description
        visible_elements = self.get_all_elements_container(top_container, only_visible=True)
        for element_container in visible_elements:
            if element_container[1] is not self.get_player():
                if element_container[1] is not self.player_location:
                    description = description + &#34;\n&#34; +\
                        element_in_container(element_container[0].name,\
                        element_container[1].preposition,\
                        element_container[1].name)
                else:
                    if not isinstanceorsubclass(element_container[0], Player):
                        description = description + &#34;\n&#34; + element_container[0].description
                    if isinstanceorsubclass(element_container[0], Door):
                        description = description + &#34; &#34; + door_leads_to(self.get_door_directions(element_container))
        return description

    def get_door_directions(self, door_container: Tuple[Door, Element]):
        &#34;&#34;&#34;Get the directions a door leads to&#34;&#34;&#34;
        directions = [] 
        for direction_location in door_container[1].exits.items():
            if direction_location[1] in door_container[0].connects:
                directions.append(direction_location[0])
        return directions

    def get_element_container(self, compare_element_name: str, container: Element, only_visible: bool = True):
        &#34;&#34;&#34;Get an element in the container
        by its name and the corresponding container.
        If it&#39;s not found it returns None&#34;&#34;&#34;
        vague_matches = []
        for element_container in self.get_all_elements_container(container, only_visible):
            element = element_container[0]
            if bool(set(compare_element_name.lower().split()) &amp; set(element.name.lower().split())):
                vague_matches.append((element, element_container[1]))
        if len(vague_matches) &gt; 1:
            for vague_match in vague_matches:
                if vague_match[0].name.lower() == compare_element_name.lower():
                    return vague_match
        if len(vague_matches) == 1:
            return vague_matches[0]
        return None

    def get_all_elements_container(self, container: Element, only_visible: bool = False, only_takeable: bool = False):
        &#34;&#34;&#34;Recursive method to get all elements in the container
        and their corresponding container. If there is nothing it returns None&#34;&#34;&#34;
        elements_container = []
        if only_takeable:
            for element in container.contents:
                if isinstanceorsubclass(element, Thing) and element.visible and not element.fixed:
                    elements_container.append((element, container))
                elements_container = elements_container +\
                    self.get_all_elements_container(element, only_visible, only_takeable)
            return elements_container
        if only_visible:
            for element in container.contents:
                if element.visible:
                    elements_container.append((element, container))
                if isinstanceorsubclass(element, Chest) and not element.peekable or\
                isinstanceorsubclass(element, Chest) and not element.open:
                    pass
                else:
                    elements_container = elements_container +\
                        self.get_all_elements_container(element, only_visible)
            return elements_container
        if not only_visible:
            for element in container.contents:
                elements_container.append((element, container))
                elements_container = elements_container +\
                    self.get_all_elements_container(element, only_visible)
            return elements_container
        return None

    def take(self, element_name: str):
        &#34;&#34;&#34;Take all elements or a single element and put it into the players inventory&#34;&#34;&#34;
        if element_name == &#34;all&#34;:
            all_takeable = self.get_all_elements_container(self.player_location, only_takeable=True)
            response = &#34;&#34;
            for element_container in all_takeable:
                if not isinstanceorsubclass(element_container[0], Player) and not element_container[0].fixed:
                    element_container[1].contents.remove(element_container[0])
                    self.get_player().contents.append(element_container[0])
                    response = response + picked_up_element(element_container[0].name) + &#34;\n&#34;
            return response
        element_container = self.get_element_container(element_name, self.player_location)
        if not element_container:
            return element_not_found(element_name)
        element_container[1].contents.remove(element_container[0])
        self.get_player().contents.append(element_container[0])
        return picked_up_element(element_container[0].name)

    def get_player_inventory(self):
        &#34;&#34;&#34;Returns the invenotry of the player as a string listing all things&#34;&#34;&#34;
        description = &#34;&#34;
        for element in self.get_player().contents:
            description = description + element.name + &#34;\n&#34;
        return description

    def save(self):
        &#34;&#34;&#34;Saves the game state to file&#34;&#34;&#34;
        if self.save_handler.save(self.all_name_locations, pkg_resources.resource_filename(&#34;game.data&#34;, &#34;save.json&#34;)):
            return SAVED_GAME_MESSAGE
        return FAILED_SAVE_MESSAGE

    def load(self, filename: str):
        &#34;&#34;&#34;Loads the game state from file&#34;&#34;&#34;
        load_data = self.save_handler.load(filename)
        self.all_name_locations = load_data[0]
        self.player_location = load_data[1]
        return LOADED_SAVE_MESSAGE

    def throw(self, instructions: str):
        &#34;&#34;&#34;Throws an item&#34;&#34;&#34;
        if &#34;at&#34; in instructions:
            thing_target = instructions.split(&#34; at &#34;)
            thing_container = self.get_element_container(thing_target[0], self.get_player())[0]
            if thing_container is None:
                return element_not_found(thing_container.name)
            target_container = self.get_element_container(thing_target[1], self.player_location)[0]
            if target_container is None:
                return element_not_found(target_container.name)
            if isinstanceorsubclass(target_container, Animate):
                self.get_player().contents.remove(thing_container)
                target_container.health = target_container.health - thing_container.damage * 1.5
                self.player_location.contents.append(thing_container)
                return hit_target(target_container.name)
        thing_container = self.get_element_container(instructions, self.player_location)
        self.get_player().contents.remove(thing_container[0])
        self.player_location.contents.append(thing_container[0])
        return THREW_AT_NOTHING

    def close(self, element_name: str):
        &#34;&#34;&#34;Closes a door or chest element&#34;&#34;&#34;
        element_container = self.get_element_container(element_name, self.player_location)
        if isinstanceorsubclass(element_container[0], (Chest, Door)):
            element_container[0].open = False
            return CLOSED
        return NOT_OPENABLE

    def read(self, element_name: str):
        &#34;&#34;&#34;Read an elements text&#34;&#34;&#34;
        element_container = self.get_element_container(element_name, self.player_location)
        if isinstanceorsubclass(element_container[0], Thing) and element_container[0].text:
            return element_container[0].text
        return NOT_READABLE

    def put(self, instructions: str):
        &#34;&#34;&#34;Put element into the contents of another element&#34;&#34;&#34;
        if &#34; in &#34; in instructions or &#34; on &#34; in instructions:
            thing_target = re.split(&#34; in | on &#34;, instructions)
            thing_container = self.get_element_container(thing_target[0], self.get_player())
            if thing_container is None:
                return element_not_found(thing_target[0])
            target_container = self.get_element_container(thing_target[1], self.player_location)
            if target_container is None:
                return element_not_found(thing_target[1])
            thing_container[1].contents.remove(thing_container[0])
            target_container[0].contents.append(thing_container[0])
            return DONE
        return TARGET_NOT_SPECIFIED

    def activate(self, instructions: str, expected_activator_type: ActivatorType):
        &#34;&#34;&#34;Activate an activator&#34;&#34;&#34;
        split_input = instructions.split()
        if &#34;on&#34; in instructions.split():
            split_input.remove(&#34;on&#34;)
            activator = self.get_element_container(split_input[0], self.player_location)[0]
            if not self.turn_on(activator, self.activator_handler):
                return ALREADY_ON
            return TURNED_ON
        if &#34;off&#34; in instructions.split():
            split_input.remove(&#34;off&#34;)
            activator = self.get_element_container(split_input[0], self.player_location)[0]
            if not self.turn_off(activator, self.activator_handler):
                return ALREADY_OFF
            return TURNED_OFF
        activator = self.get_element_container(instructions, self.player_location)[0]
        if not activator:
            return element_not_found(instructions)
        if not expected_activator_type is activator.type:
            return ACTION_NOT_POSSIBLE
        if activator.is_on is True:
            return self.turn_off(activator, self.activator_handler)
        if activator.is_on is False:
            return self.turn_on(activator, self.activator_handler)
        return ACTION_FAILED

    def turn_on(self, activator: Activator, activator_handler: ActivatorController):
        &#34;&#34;&#34;Turns an activator on&#34;&#34;&#34;
        if activator.is_on:
            return ALREADY_ON
        turn_on_method = getattr(activator_handler, activator.turn_on_method_name)
        activator.is_on = True
        if turn_on_method:
            return turn_on_method()
        return NOTHING_HAPPENS

    def turn_off(self, activator: Activator, activator_handler: ActivatorController):
        &#34;&#34;&#34;Turns an activator off&#34;&#34;&#34;
        if not activator.is_on:
            return ALREADY_OFF
        turn_off_method = getattr(activator_handler, activator.turn_off_method_name)
        activator.is_on = False
        if turn_off_method:
            return turn_off_method()
        return NOTHING_HAPPENS

    def move_element(self, element_name: str):
        &#34;&#34;&#34;Moves element&#34;&#34;&#34;
        element_container = self.get_element_container(element_name, self.player_location)
        if not element_container:
            return element_not_found(element_name)
        element_container[0].moved = True
        revealed_element = self.get_element_container(element_container[0].reveals,\
            self.player_location, only_visible=False)[0]
        revealed_element.visible = True
        return reveal_element(element_name, revealed_element.description.lower())

    def attack(self, instructions: str):
        &#34;&#34;&#34;Attacks a target&#34;&#34;&#34;
        if &#34;with&#34; in instructions:
            target_thing = instructions.split(&#34; with &#34;)
            tool_container = self.get_element_container(target_thing[1], self.get_player())
            if tool_container is None:
                return element_not_in_inventory(target_thing[1])
            if not isinstanceorsubclass(tool_container[0], Tool):
                return NEEDS_TO_BE_TOOL
            target_container = self.get_element_container(target_thing[0], self.player_location)
            if target_container is None:
                return element_not_found(target_thing[0])
            if isinstanceorsubclass(target_container[0], Animate):
                target_container[0].health = target_container[0].health - tool_container[0].damage
                return hit_target(target_container[0].name)
            if isinstanceorsubclass(target_container[0], Thing):
                if not target_container[0].when_broken_do:
                    return CANT_BREAK
                break_method = getattr(self.activator_handler, target_container[0].when_broken_do)
                target_container[1].contents.remove(target_container[0])
                target_container[1].contents.append(\
                    Thing(&#34;broken &#34; + target_container[0].name,\
                    target_container[0].description))
                return break_method()
        return WEAPON_NOT_SPECIFIED

    def eat(self, element_name: str):
        &#34;&#34;&#34;Feeds the player&#34;&#34;&#34;
        food = self.get_element_container(element_name, self.player_location)[0]
        if not food:
            return element_not_found(food)
        self.get_player().health += food.regen
        return eat_food(food.name, food.taste)

    def tie(self, instructions: str):
        &#34;&#34;&#34;Ties a rope to something&#34;&#34;&#34;
        if &#34;to&#34; in instructions:
            thing_target = instructions.split(&#34; to &#34;)
            thing_container = self.get_element_container(thing_target[0], self.get_player())
            if thing_container is None:
                return element_not_in_inventory(thing_target[0])
            target_container = self.get_element_container(thing_target[1], self.player_location)
            if target_container is None:
                return element_not_found(thing_target[1])
            if not isinstanceorsubclass(target_container[0], Thing):
                return CANT_TIE_TO_ELEMENT
            if not target_container[0].fixed:
                return THAT_WONT_HOLD
            if isinstanceorsubclass(thing_container[0], Rope):
                self.get_player().contents.remove(thing_container[0])
                target_container[1].contents.append(thing_container[0])
                thing_container[0].tied_to = target_container[0].name
                return tie_rope_to_target(target_container[0].name.lower())
        return TARGET_NOT_SPECIFIED

    def untie(self, rope_name: str):
        &#34;&#34;&#34;Unties a rope&#34;&#34;&#34;
        rope = self.get_element_container(rope_name, self.player_location)
        if rope is None:
            return element_not_found(rope_name)
        if self.get_element_container(rope.tied_to, self.player_location):
            rope.tied_to = None
            return UNTIE
        return ALREADY_UNTIED

    def listen(self):
        &#34;&#34;&#34;Listens to environment&#34;&#34;&#34;
        noises = []
        for element_container in self.get_all_elements_container(self.player_location):
            if element_container[0].sound:
                noises.append(element_container[0].sound)
        if len(noises) == 0:
            return SILENCE
        return noises_description(noises)

    def smell(self):
        &#34;&#34;&#34;Smells the environment&#34;&#34;&#34;
        smells = []
        for element_container in self.get_all_elements_container(self.player_location):
            if element_container[0].smell:
                smells.append(element_container[0].smell)
        if len(smells) == 0:
            return NO_SMELLS
        return smell_description(smells)

    def hide(self, instructions: str):
        &#34;&#34;&#34;Hides player in thing&#34;&#34;&#34;
        if &#34;in&#34; in instructions or &#34;under&#34; in instructions:
            target = re.split(&#34;in|under&#34;, instructions)[1]
            element_container = self.get_element_container(target, self.player_location)
            if isinstanceorsubclass(element_container[0], Thing) and element_container[0].enterable:
                self.get_player().hiding = True
                return entering_thing(element_container[0].name)
            return NOT_ENTERABLE
        return SPECIFIY_HIDING_PLACE

    def appear(self):
        &#34;&#34;&#34;Puts player out of hiding&#34;&#34;&#34;
        player = self.get_player()
        if player.hiding is True:
            player.hiding = False
            return APPEARING
        return NOT_HIDING</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="game.controller.dungeon_controller.DungeonController.activate"><code class="name flex">
<span>def <span class="ident">activate</span></span>(<span>self, instructions:str, expected_activator_type:<a title="game.model.enums.activator_type.ActivatorType" href="../model/enums/activator_type.html#game.model.enums.activator_type.ActivatorType">ActivatorType</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Activate an activator</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def activate(self, instructions: str, expected_activator_type: ActivatorType):
    &#34;&#34;&#34;Activate an activator&#34;&#34;&#34;
    split_input = instructions.split()
    if &#34;on&#34; in instructions.split():
        split_input.remove(&#34;on&#34;)
        activator = self.get_element_container(split_input[0], self.player_location)[0]
        if not self.turn_on(activator, self.activator_handler):
            return ALREADY_ON
        return TURNED_ON
    if &#34;off&#34; in instructions.split():
        split_input.remove(&#34;off&#34;)
        activator = self.get_element_container(split_input[0], self.player_location)[0]
        if not self.turn_off(activator, self.activator_handler):
            return ALREADY_OFF
        return TURNED_OFF
    activator = self.get_element_container(instructions, self.player_location)[0]
    if not activator:
        return element_not_found(instructions)
    if not expected_activator_type is activator.type:
        return ACTION_NOT_POSSIBLE
    if activator.is_on is True:
        return self.turn_off(activator, self.activator_handler)
    if activator.is_on is False:
        return self.turn_on(activator, self.activator_handler)
    return ACTION_FAILED</code></pre>
</details>
</dd>
<dt id="game.controller.dungeon_controller.DungeonController.appear"><code class="name flex">
<span>def <span class="ident">appear</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Puts player out of hiding</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def appear(self):
    &#34;&#34;&#34;Puts player out of hiding&#34;&#34;&#34;
    player = self.get_player()
    if player.hiding is True:
        player.hiding = False
        return APPEARING
    return NOT_HIDING</code></pre>
</details>
</dd>
<dt id="game.controller.dungeon_controller.DungeonController.attack"><code class="name flex">
<span>def <span class="ident">attack</span></span>(<span>self, instructions:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Attacks a target</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attack(self, instructions: str):
    &#34;&#34;&#34;Attacks a target&#34;&#34;&#34;
    if &#34;with&#34; in instructions:
        target_thing = instructions.split(&#34; with &#34;)
        tool_container = self.get_element_container(target_thing[1], self.get_player())
        if tool_container is None:
            return element_not_in_inventory(target_thing[1])
        if not isinstanceorsubclass(tool_container[0], Tool):
            return NEEDS_TO_BE_TOOL
        target_container = self.get_element_container(target_thing[0], self.player_location)
        if target_container is None:
            return element_not_found(target_thing[0])
        if isinstanceorsubclass(target_container[0], Animate):
            target_container[0].health = target_container[0].health - tool_container[0].damage
            return hit_target(target_container[0].name)
        if isinstanceorsubclass(target_container[0], Thing):
            if not target_container[0].when_broken_do:
                return CANT_BREAK
            break_method = getattr(self.activator_handler, target_container[0].when_broken_do)
            target_container[1].contents.remove(target_container[0])
            target_container[1].contents.append(\
                Thing(&#34;broken &#34; + target_container[0].name,\
                target_container[0].description))
            return break_method()
    return WEAPON_NOT_SPECIFIED</code></pre>
</details>
</dd>
<dt id="game.controller.dungeon_controller.DungeonController.brief"><code class="name flex">
<span>def <span class="ident">brief</span></span>(<span>self, room_name:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Debrief the player if they arrive at a location they've never been</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def brief(self, room_name: str):
    &#34;&#34;&#34;Debrief the player if they arrive at a location they&#39;ve never been&#34;&#34;&#34;
    for name_location in self.all_name_locations:
        if name_location[0] == room_name and not name_location[1].visited and name_location[1].brief:
            name_location[1].visited = True
            return name_location[1].brief + &#34;\n\n&#34;
    return &#34;&#34;</code></pre>
</details>
</dd>
<dt id="game.controller.dungeon_controller.DungeonController.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self, element_name:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Closes a door or chest element</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self, element_name: str):
    &#34;&#34;&#34;Closes a door or chest element&#34;&#34;&#34;
    element_container = self.get_element_container(element_name, self.player_location)
    if isinstanceorsubclass(element_container[0], (Chest, Door)):
        element_container[0].open = False
        return CLOSED
    return NOT_OPENABLE</code></pre>
</details>
</dd>
<dt id="game.controller.dungeon_controller.DungeonController.describe"><code class="name flex">
<span>def <span class="ident">describe</span></span>(<span>self, element_name:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a desription of any kind of in-game element at the location of the player</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def describe(self, element_name: str):
    &#34;&#34;&#34;Returns a desription of any kind of in-game element at the location of the player&#34;&#34;&#34;
    element_name = element_name.lower()
    if element_name in (self.player_location.name, GENERIC_LOCATAION_NAME, &#39;&#39;):
        return self.describe_location()
    return self.describe_element(element_name)</code></pre>
</details>
</dd>
<dt id="game.controller.dungeon_controller.DungeonController.describe_container"><code class="name flex">
<span>def <span class="ident">describe_container</span></span>(<span>self, top_container:<a title="game.model.element.Element" href="../model/element.html#game.model.element.Element">Element</a>, prefix_suffix=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Descsribe any container and its contents and all the contents contents etc.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def describe_container(self, top_container: Element, prefix_suffix=None):
    &#34;&#34;&#34;Descsribe any container and its contents and all the contents contents etc.&#34;&#34;&#34;
    if prefix_suffix:
        description = top_container.name + &#34;\n&#34; + prefix_suffix[0] +\
            top_container.description.lower() + prefix_suffix[1]
    else:
        description = top_container.description
    visible_elements = self.get_all_elements_container(top_container, only_visible=True)
    for element_container in visible_elements:
        if element_container[1] is not self.get_player():
            if element_container[1] is not self.player_location:
                description = description + &#34;\n&#34; +\
                    element_in_container(element_container[0].name,\
                    element_container[1].preposition,\
                    element_container[1].name)
            else:
                if not isinstanceorsubclass(element_container[0], Player):
                    description = description + &#34;\n&#34; + element_container[0].description
                if isinstanceorsubclass(element_container[0], Door):
                    description = description + &#34; &#34; + door_leads_to(self.get_door_directions(element_container))
    return description</code></pre>
</details>
</dd>
<dt id="game.controller.dungeon_controller.DungeonController.describe_element"><code class="name flex">
<span>def <span class="ident">describe_element</span></span>(<span>self, element_name:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Get description of a single element</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def describe_element(self, element_name: str):
    &#34;&#34;&#34;Get description of a single element&#34;&#34;&#34;
    element_container = self.get_element_container(element_name, self.player_location)
    if element_container:
        return self.describe_container(element_container[0])
    else:
        return element_not_found(element_name)</code></pre>
</details>
</dd>
<dt id="game.controller.dungeon_controller.DungeonController.describe_location"><code class="name flex">
<span>def <span class="ident">describe_location</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Describes the location where the player is</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def describe_location(self):
    &#34;&#34;&#34;Describes the location where the player is&#34;&#34;&#34;
    if not self.get_player().hiding:
        return self.describe_container(self.player_location, (LOCATION_PREFIX, LOCATION_SUFFIX))
    return CANT_SEE_LOCATION_FROM_HIDING</code></pre>
</details>
</dd>
<dt id="game.controller.dungeon_controller.DungeonController.eat"><code class="name flex">
<span>def <span class="ident">eat</span></span>(<span>self, element_name:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Feeds the player</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eat(self, element_name: str):
    &#34;&#34;&#34;Feeds the player&#34;&#34;&#34;
    food = self.get_element_container(element_name, self.player_location)[0]
    if not food:
        return element_not_found(food)
    self.get_player().health += food.regen
    return eat_food(food.name, food.taste)</code></pre>
</details>
</dd>
<dt id="game.controller.dungeon_controller.DungeonController.get_all_elements_container"><code class="name flex">
<span>def <span class="ident">get_all_elements_container</span></span>(<span>self, container:<a title="game.model.element.Element" href="../model/element.html#game.model.element.Element">Element</a>, only_visible:bool=False, only_takeable:bool=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Recursive method to get all elements in the container
and their corresponding container. If there is nothing it returns None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_elements_container(self, container: Element, only_visible: bool = False, only_takeable: bool = False):
    &#34;&#34;&#34;Recursive method to get all elements in the container
    and their corresponding container. If there is nothing it returns None&#34;&#34;&#34;
    elements_container = []
    if only_takeable:
        for element in container.contents:
            if isinstanceorsubclass(element, Thing) and element.visible and not element.fixed:
                elements_container.append((element, container))
            elements_container = elements_container +\
                self.get_all_elements_container(element, only_visible, only_takeable)
        return elements_container
    if only_visible:
        for element in container.contents:
            if element.visible:
                elements_container.append((element, container))
            if isinstanceorsubclass(element, Chest) and not element.peekable or\
            isinstanceorsubclass(element, Chest) and not element.open:
                pass
            else:
                elements_container = elements_container +\
                    self.get_all_elements_container(element, only_visible)
        return elements_container
    if not only_visible:
        for element in container.contents:
            elements_container.append((element, container))
            elements_container = elements_container +\
                self.get_all_elements_container(element, only_visible)
        return elements_container
    return None</code></pre>
</details>
</dd>
<dt id="game.controller.dungeon_controller.DungeonController.get_door_directions"><code class="name flex">
<span>def <span class="ident">get_door_directions</span></span>(<span>self, door_container:Tuple[<a title="game.model.door.Door" href="../model/door.html#game.model.door.Door">Door</a>,<a title="game.model.element.Element" href="../model/element.html#game.model.element.Element">Element</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>Get the directions a door leads to</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_door_directions(self, door_container: Tuple[Door, Element]):
    &#34;&#34;&#34;Get the directions a door leads to&#34;&#34;&#34;
    directions = [] 
    for direction_location in door_container[1].exits.items():
        if direction_location[1] in door_container[0].connects:
            directions.append(direction_location[0])
    return directions</code></pre>
</details>
</dd>
<dt id="game.controller.dungeon_controller.DungeonController.get_element_container"><code class="name flex">
<span>def <span class="ident">get_element_container</span></span>(<span>self, compare_element_name:str, container:<a title="game.model.element.Element" href="../model/element.html#game.model.element.Element">Element</a>, only_visible:bool=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Get an element in the container
by its name and the corresponding container.
If it's not found it returns None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element_container(self, compare_element_name: str, container: Element, only_visible: bool = True):
    &#34;&#34;&#34;Get an element in the container
    by its name and the corresponding container.
    If it&#39;s not found it returns None&#34;&#34;&#34;
    vague_matches = []
    for element_container in self.get_all_elements_container(container, only_visible):
        element = element_container[0]
        if bool(set(compare_element_name.lower().split()) &amp; set(element.name.lower().split())):
            vague_matches.append((element, element_container[1]))
    if len(vague_matches) &gt; 1:
        for vague_match in vague_matches:
            if vague_match[0].name.lower() == compare_element_name.lower():
                return vague_match
    if len(vague_matches) == 1:
        return vague_matches[0]
    return None</code></pre>
</details>
</dd>
<dt id="game.controller.dungeon_controller.DungeonController.get_health"><code class="name flex">
<span>def <span class="ident">get_health</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the current health</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_health(self):
    &#34;&#34;&#34;Get the current health&#34;&#34;&#34;
    return self.get_player().health</code></pre>
</details>
</dd>
<dt id="game.controller.dungeon_controller.DungeonController.get_player"><code class="name flex">
<span>def <span class="ident">get_player</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the player object from the current location</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_player(self):
    &#34;&#34;&#34;Get the player object from the current location&#34;&#34;&#34;
    return self.get_element_container(&#34;Player&#34;, self.player_location)[0]</code></pre>
</details>
</dd>
<dt id="game.controller.dungeon_controller.DungeonController.get_player_inventory"><code class="name flex">
<span>def <span class="ident">get_player_inventory</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the invenotry of the player as a string listing all things</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_player_inventory(self):
    &#34;&#34;&#34;Returns the invenotry of the player as a string listing all things&#34;&#34;&#34;
    description = &#34;&#34;
    for element in self.get_player().contents:
        description = description + element.name + &#34;\n&#34;
    return description</code></pre>
</details>
</dd>
<dt id="game.controller.dungeon_controller.DungeonController.get_score"><code class="name flex">
<span>def <span class="ident">get_score</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the current score</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_score(self):
    &#34;&#34;&#34;Get the current score&#34;&#34;&#34;
    return self.player_score</code></pre>
</details>
</dd>
<dt id="game.controller.dungeon_controller.DungeonController.hide"><code class="name flex">
<span>def <span class="ident">hide</span></span>(<span>self, instructions:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Hides player in thing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hide(self, instructions: str):
    &#34;&#34;&#34;Hides player in thing&#34;&#34;&#34;
    if &#34;in&#34; in instructions or &#34;under&#34; in instructions:
        target = re.split(&#34;in|under&#34;, instructions)[1]
        element_container = self.get_element_container(target, self.player_location)
        if isinstanceorsubclass(element_container[0], Thing) and element_container[0].enterable:
            self.get_player().hiding = True
            return entering_thing(element_container[0].name)
        return NOT_ENTERABLE
    return SPECIFIY_HIDING_PLACE</code></pre>
</details>
</dd>
<dt id="game.controller.dungeon_controller.DungeonController.listen"><code class="name flex">
<span>def <span class="ident">listen</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Listens to environment</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def listen(self):
    &#34;&#34;&#34;Listens to environment&#34;&#34;&#34;
    noises = []
    for element_container in self.get_all_elements_container(self.player_location):
        if element_container[0].sound:
            noises.append(element_container[0].sound)
    if len(noises) == 0:
        return SILENCE
    return noises_description(noises)</code></pre>
</details>
</dd>
<dt id="game.controller.dungeon_controller.DungeonController.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>self, filename:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads the game state from file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load(self, filename: str):
    &#34;&#34;&#34;Loads the game state from file&#34;&#34;&#34;
    load_data = self.save_handler.load(filename)
    self.all_name_locations = load_data[0]
    self.player_location = load_data[1]
    return LOADED_SAVE_MESSAGE</code></pre>
</details>
</dd>
<dt id="game.controller.dungeon_controller.DungeonController.move_element"><code class="name flex">
<span>def <span class="ident">move_element</span></span>(<span>self, element_name:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Moves element</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move_element(self, element_name: str):
    &#34;&#34;&#34;Moves element&#34;&#34;&#34;
    element_container = self.get_element_container(element_name, self.player_location)
    if not element_container:
        return element_not_found(element_name)
    element_container[0].moved = True
    revealed_element = self.get_element_container(element_container[0].reveals,\
        self.player_location, only_visible=False)[0]
    revealed_element.visible = True
    return reveal_element(element_name, revealed_element.description.lower())</code></pre>
</details>
</dd>
<dt id="game.controller.dungeon_controller.DungeonController.move_player"><code class="name flex">
<span>def <span class="ident">move_player</span></span>(<span>self, direction:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Move the player from one location to the next, which lies in the given direction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move_player(self, direction: str):
    &#34;&#34;&#34;Move the player from one location to the next, which lies in the given direction&#34;&#34;&#34;
    if direction in self.player_location.exits:
        travel_text = &#34;&#34;
        all_name_rooms_dict =  dict(self.all_name_locations)
        next_room = all_name_rooms_dict[self.player_location.exits[direction]]
        room_has_attached_rope = False
        for element in self.player_location.contents:
            if isinstanceorsubclass(element, Door):
                if next_room.name in element.connects and element.locked:
                    return LOCKED_DOOR
                element.open = True
            if isinstanceorsubclass(element, Rope) and direction == DOWN and next_room.needs_rope:
                if not element.tied_to:
                    return NO_TIED_ROPE
                room_has_attached_rope = True
                travel_text = CLIMBING_DOWN + &#34;\n&#34;
        if next_room.needs_rope and room_has_attached_rope is False:
            return NO_TIED_ROPE
        player = self.get_player()
        self.player_location.contents.remove(player)
        self.set_player_location(player, next_room)
        brief_text = &#34;&#34;
        brief_text = self.brief(next_room.name)
        return f&#34;{travel_text}{brief_text}{self.player_location.name}&#34;
    return INVALID_DIRECTION</code></pre>
</details>
</dd>
<dt id="game.controller.dungeon_controller.DungeonController.put"><code class="name flex">
<span>def <span class="ident">put</span></span>(<span>self, instructions:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Put element into the contents of another element</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put(self, instructions: str):
    &#34;&#34;&#34;Put element into the contents of another element&#34;&#34;&#34;
    if &#34; in &#34; in instructions or &#34; on &#34; in instructions:
        thing_target = re.split(&#34; in | on &#34;, instructions)
        thing_container = self.get_element_container(thing_target[0], self.get_player())
        if thing_container is None:
            return element_not_found(thing_target[0])
        target_container = self.get_element_container(thing_target[1], self.player_location)
        if target_container is None:
            return element_not_found(thing_target[1])
        thing_container[1].contents.remove(thing_container[0])
        target_container[0].contents.append(thing_container[0])
        return DONE
    return TARGET_NOT_SPECIFIED</code></pre>
</details>
</dd>
<dt id="game.controller.dungeon_controller.DungeonController.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, element_name:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Read an elements text</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, element_name: str):
    &#34;&#34;&#34;Read an elements text&#34;&#34;&#34;
    element_container = self.get_element_container(element_name, self.player_location)
    if isinstanceorsubclass(element_container[0], Thing) and element_container[0].text:
        return element_container[0].text
    return NOT_READABLE</code></pre>
</details>
</dd>
<dt id="game.controller.dungeon_controller.DungeonController.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves the game state to file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self):
    &#34;&#34;&#34;Saves the game state to file&#34;&#34;&#34;
    if self.save_handler.save(self.all_name_locations, pkg_resources.resource_filename(&#34;game.data&#34;, &#34;save.json&#34;)):
        return SAVED_GAME_MESSAGE
    return FAILED_SAVE_MESSAGE</code></pre>
</details>
</dd>
<dt id="game.controller.dungeon_controller.DungeonController.set_player_location"><code class="name flex">
<span>def <span class="ident">set_player_location</span></span>(<span>self, player:<a title="game.model.player.Player" href="../model/player.html#game.model.player.Player">Player</a>, location:<a title="game.model.location.Location" href="../model/location.html#game.model.location.Location">Location</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the players location to a new one</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_player_location(self, player: Player, location: Location):
    &#34;&#34;&#34;Update the players location to a new one&#34;&#34;&#34;
    location.contents.append(player)
    self.player_location = location</code></pre>
</details>
</dd>
<dt id="game.controller.dungeon_controller.DungeonController.smell"><code class="name flex">
<span>def <span class="ident">smell</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Smells the environment</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def smell(self):
    &#34;&#34;&#34;Smells the environment&#34;&#34;&#34;
    smells = []
    for element_container in self.get_all_elements_container(self.player_location):
        if element_container[0].smell:
            smells.append(element_container[0].smell)
    if len(smells) == 0:
        return NO_SMELLS
    return smell_description(smells)</code></pre>
</details>
</dd>
<dt id="game.controller.dungeon_controller.DungeonController.take"><code class="name flex">
<span>def <span class="ident">take</span></span>(<span>self, element_name:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Take all elements or a single element and put it into the players inventory</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def take(self, element_name: str):
    &#34;&#34;&#34;Take all elements or a single element and put it into the players inventory&#34;&#34;&#34;
    if element_name == &#34;all&#34;:
        all_takeable = self.get_all_elements_container(self.player_location, only_takeable=True)
        response = &#34;&#34;
        for element_container in all_takeable:
            if not isinstanceorsubclass(element_container[0], Player) and not element_container[0].fixed:
                element_container[1].contents.remove(element_container[0])
                self.get_player().contents.append(element_container[0])
                response = response + picked_up_element(element_container[0].name) + &#34;\n&#34;
        return response
    element_container = self.get_element_container(element_name, self.player_location)
    if not element_container:
        return element_not_found(element_name)
    element_container[1].contents.remove(element_container[0])
    self.get_player().contents.append(element_container[0])
    return picked_up_element(element_container[0].name)</code></pre>
</details>
</dd>
<dt id="game.controller.dungeon_controller.DungeonController.throw"><code class="name flex">
<span>def <span class="ident">throw</span></span>(<span>self, instructions:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Throws an item</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def throw(self, instructions: str):
    &#34;&#34;&#34;Throws an item&#34;&#34;&#34;
    if &#34;at&#34; in instructions:
        thing_target = instructions.split(&#34; at &#34;)
        thing_container = self.get_element_container(thing_target[0], self.get_player())[0]
        if thing_container is None:
            return element_not_found(thing_container.name)
        target_container = self.get_element_container(thing_target[1], self.player_location)[0]
        if target_container is None:
            return element_not_found(target_container.name)
        if isinstanceorsubclass(target_container, Animate):
            self.get_player().contents.remove(thing_container)
            target_container.health = target_container.health - thing_container.damage * 1.5
            self.player_location.contents.append(thing_container)
            return hit_target(target_container.name)
    thing_container = self.get_element_container(instructions, self.player_location)
    self.get_player().contents.remove(thing_container[0])
    self.player_location.contents.append(thing_container[0])
    return THREW_AT_NOTHING</code></pre>
</details>
</dd>
<dt id="game.controller.dungeon_controller.DungeonController.tie"><code class="name flex">
<span>def <span class="ident">tie</span></span>(<span>self, instructions:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Ties a rope to something</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tie(self, instructions: str):
    &#34;&#34;&#34;Ties a rope to something&#34;&#34;&#34;
    if &#34;to&#34; in instructions:
        thing_target = instructions.split(&#34; to &#34;)
        thing_container = self.get_element_container(thing_target[0], self.get_player())
        if thing_container is None:
            return element_not_in_inventory(thing_target[0])
        target_container = self.get_element_container(thing_target[1], self.player_location)
        if target_container is None:
            return element_not_found(thing_target[1])
        if not isinstanceorsubclass(target_container[0], Thing):
            return CANT_TIE_TO_ELEMENT
        if not target_container[0].fixed:
            return THAT_WONT_HOLD
        if isinstanceorsubclass(thing_container[0], Rope):
            self.get_player().contents.remove(thing_container[0])
            target_container[1].contents.append(thing_container[0])
            thing_container[0].tied_to = target_container[0].name
            return tie_rope_to_target(target_container[0].name.lower())
    return TARGET_NOT_SPECIFIED</code></pre>
</details>
</dd>
<dt id="game.controller.dungeon_controller.DungeonController.turn_off"><code class="name flex">
<span>def <span class="ident">turn_off</span></span>(<span>self, activator:<a title="game.model.activator.Activator" href="../model/activator.html#game.model.activator.Activator">Activator</a>, activator_handler:<a title="game.controller.activator_controller.ActivatorController" href="activator_controller.html#game.controller.activator_controller.ActivatorController">ActivatorController</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Turns an activator off</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def turn_off(self, activator: Activator, activator_handler: ActivatorController):
    &#34;&#34;&#34;Turns an activator off&#34;&#34;&#34;
    if not activator.is_on:
        return ALREADY_OFF
    turn_off_method = getattr(activator_handler, activator.turn_off_method_name)
    activator.is_on = False
    if turn_off_method:
        return turn_off_method()
    return NOTHING_HAPPENS</code></pre>
</details>
</dd>
<dt id="game.controller.dungeon_controller.DungeonController.turn_on"><code class="name flex">
<span>def <span class="ident">turn_on</span></span>(<span>self, activator:<a title="game.model.activator.Activator" href="../model/activator.html#game.model.activator.Activator">Activator</a>, activator_handler:<a title="game.controller.activator_controller.ActivatorController" href="activator_controller.html#game.controller.activator_controller.ActivatorController">ActivatorController</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Turns an activator on</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def turn_on(self, activator: Activator, activator_handler: ActivatorController):
    &#34;&#34;&#34;Turns an activator on&#34;&#34;&#34;
    if activator.is_on:
        return ALREADY_ON
    turn_on_method = getattr(activator_handler, activator.turn_on_method_name)
    activator.is_on = True
    if turn_on_method:
        return turn_on_method()
    return NOTHING_HAPPENS</code></pre>
</details>
</dd>
<dt id="game.controller.dungeon_controller.DungeonController.unlock"><code class="name flex">
<span>def <span class="ident">unlock</span></span>(<span>self, door_name:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Unlocks and opens a door</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unlock(self, door_name: str):
    &#34;&#34;&#34;Unlocks and opens a door&#34;&#34;&#34;
    door = self.get_element_container(door_name, self.player_location)[0]
    if not door.locked:
        return door_not_locked(door_name)
    if any(element.name == door.key for element in self.get_player().contents):
        self.player_score = self.player_score + 1
        door.locked = False
        return door_unlocked(door_name)
    return KEY_MISSING</code></pre>
</details>
</dd>
<dt id="game.controller.dungeon_controller.DungeonController.untie"><code class="name flex">
<span>def <span class="ident">untie</span></span>(<span>self, rope_name:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Unties a rope</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def untie(self, rope_name: str):
    &#34;&#34;&#34;Unties a rope&#34;&#34;&#34;
    rope = self.get_element_container(rope_name, self.player_location)
    if rope is None:
        return element_not_found(rope_name)
    if self.get_element_container(rope.tied_to, self.player_location):
        rope.tied_to = None
        return UNTIE
    return ALREADY_UNTIED</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="game.controller" href="index.html">game.controller</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="game.controller.dungeon_controller.DungeonController" href="#game.controller.dungeon_controller.DungeonController">DungeonController</a></code></h4>
<ul class="">
<li><code><a title="game.controller.dungeon_controller.DungeonController.activate" href="#game.controller.dungeon_controller.DungeonController.activate">activate</a></code></li>
<li><code><a title="game.controller.dungeon_controller.DungeonController.appear" href="#game.controller.dungeon_controller.DungeonController.appear">appear</a></code></li>
<li><code><a title="game.controller.dungeon_controller.DungeonController.attack" href="#game.controller.dungeon_controller.DungeonController.attack">attack</a></code></li>
<li><code><a title="game.controller.dungeon_controller.DungeonController.brief" href="#game.controller.dungeon_controller.DungeonController.brief">brief</a></code></li>
<li><code><a title="game.controller.dungeon_controller.DungeonController.close" href="#game.controller.dungeon_controller.DungeonController.close">close</a></code></li>
<li><code><a title="game.controller.dungeon_controller.DungeonController.describe" href="#game.controller.dungeon_controller.DungeonController.describe">describe</a></code></li>
<li><code><a title="game.controller.dungeon_controller.DungeonController.describe_container" href="#game.controller.dungeon_controller.DungeonController.describe_container">describe_container</a></code></li>
<li><code><a title="game.controller.dungeon_controller.DungeonController.describe_element" href="#game.controller.dungeon_controller.DungeonController.describe_element">describe_element</a></code></li>
<li><code><a title="game.controller.dungeon_controller.DungeonController.describe_location" href="#game.controller.dungeon_controller.DungeonController.describe_location">describe_location</a></code></li>
<li><code><a title="game.controller.dungeon_controller.DungeonController.eat" href="#game.controller.dungeon_controller.DungeonController.eat">eat</a></code></li>
<li><code><a title="game.controller.dungeon_controller.DungeonController.get_all_elements_container" href="#game.controller.dungeon_controller.DungeonController.get_all_elements_container">get_all_elements_container</a></code></li>
<li><code><a title="game.controller.dungeon_controller.DungeonController.get_door_directions" href="#game.controller.dungeon_controller.DungeonController.get_door_directions">get_door_directions</a></code></li>
<li><code><a title="game.controller.dungeon_controller.DungeonController.get_element_container" href="#game.controller.dungeon_controller.DungeonController.get_element_container">get_element_container</a></code></li>
<li><code><a title="game.controller.dungeon_controller.DungeonController.get_health" href="#game.controller.dungeon_controller.DungeonController.get_health">get_health</a></code></li>
<li><code><a title="game.controller.dungeon_controller.DungeonController.get_player" href="#game.controller.dungeon_controller.DungeonController.get_player">get_player</a></code></li>
<li><code><a title="game.controller.dungeon_controller.DungeonController.get_player_inventory" href="#game.controller.dungeon_controller.DungeonController.get_player_inventory">get_player_inventory</a></code></li>
<li><code><a title="game.controller.dungeon_controller.DungeonController.get_score" href="#game.controller.dungeon_controller.DungeonController.get_score">get_score</a></code></li>
<li><code><a title="game.controller.dungeon_controller.DungeonController.hide" href="#game.controller.dungeon_controller.DungeonController.hide">hide</a></code></li>
<li><code><a title="game.controller.dungeon_controller.DungeonController.listen" href="#game.controller.dungeon_controller.DungeonController.listen">listen</a></code></li>
<li><code><a title="game.controller.dungeon_controller.DungeonController.load" href="#game.controller.dungeon_controller.DungeonController.load">load</a></code></li>
<li><code><a title="game.controller.dungeon_controller.DungeonController.move_element" href="#game.controller.dungeon_controller.DungeonController.move_element">move_element</a></code></li>
<li><code><a title="game.controller.dungeon_controller.DungeonController.move_player" href="#game.controller.dungeon_controller.DungeonController.move_player">move_player</a></code></li>
<li><code><a title="game.controller.dungeon_controller.DungeonController.put" href="#game.controller.dungeon_controller.DungeonController.put">put</a></code></li>
<li><code><a title="game.controller.dungeon_controller.DungeonController.read" href="#game.controller.dungeon_controller.DungeonController.read">read</a></code></li>
<li><code><a title="game.controller.dungeon_controller.DungeonController.save" href="#game.controller.dungeon_controller.DungeonController.save">save</a></code></li>
<li><code><a title="game.controller.dungeon_controller.DungeonController.set_player_location" href="#game.controller.dungeon_controller.DungeonController.set_player_location">set_player_location</a></code></li>
<li><code><a title="game.controller.dungeon_controller.DungeonController.smell" href="#game.controller.dungeon_controller.DungeonController.smell">smell</a></code></li>
<li><code><a title="game.controller.dungeon_controller.DungeonController.take" href="#game.controller.dungeon_controller.DungeonController.take">take</a></code></li>
<li><code><a title="game.controller.dungeon_controller.DungeonController.throw" href="#game.controller.dungeon_controller.DungeonController.throw">throw</a></code></li>
<li><code><a title="game.controller.dungeon_controller.DungeonController.tie" href="#game.controller.dungeon_controller.DungeonController.tie">tie</a></code></li>
<li><code><a title="game.controller.dungeon_controller.DungeonController.turn_off" href="#game.controller.dungeon_controller.DungeonController.turn_off">turn_off</a></code></li>
<li><code><a title="game.controller.dungeon_controller.DungeonController.turn_on" href="#game.controller.dungeon_controller.DungeonController.turn_on">turn_on</a></code></li>
<li><code><a title="game.controller.dungeon_controller.DungeonController.unlock" href="#game.controller.dungeon_controller.DungeonController.unlock">unlock</a></code></li>
<li><code><a title="game.controller.dungeon_controller.DungeonController.untie" href="#game.controller.dungeon_controller.DungeonController.untie">untie</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>